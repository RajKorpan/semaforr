/**!
  * Plan.h
  * 
  * /author: Anoop Aroor
  *
  *          Stores a plan as a sequence of waypoints
  */

#ifndef PLAN_H
#define PLAN_H
#include "FORRGeometry.h"
#include "Planner.h"
#include <vector>
#include <map>
#include <algorithm>
#include <iostream>
#include <fstream>

class Plan {
 public:
 
  // returns the first waypoint and removes it from the queue
  CartesianPoint dequeueWaypoint(){
	CartesianPoint waypoint;
	if(!isWaypointEmpty()){
		waypoint = waypoints[0];
		waypoints.erase(waypoints.begin());
		cout << "Current plan size = " << waypoints.size() << endl;
	}
	else{
		cout << "Waypoint list empty cannot dequeue" << endl;
	}
	return waypoint;
  }

  // checks if the waypoint is empty
  bool isWaypointEmpty(){
	if(waypoints.size() > 0){
		return false;
	}
	else{
		return true;
	}
  }

  // generates new waypoints given source, target and a planner, initialized with a map
  bool generateWaypoints(CartesianPoint source, CartesianPoint target, Planner *planner){
	waypoints.clear();
	//a_star planner works in cms so all units are converts into cm
	//once plan is generated waypoints are stored in meters
        Node s(1, source.getX()*100, source.getY()*100);
	planner->setSource(s);
	Node t(1, target.getX()*100, target.getY()*100);
	planner->setTarget(t);

        cout << "plan generation status" << planner->calcPath(false) << endl;

	list<int> path = planner->getPath();
	Graph *navGraph = planner->getGraph();

	list<int>::iterator it;
	for ( it = path.begin(); it != path.end(); it++ ){
		int x = navGraph->getNode(*it).getX()/100.0;
		int y = navGraph->getNode(*it).getY()/100.0;
    		cout << x << " " << y << endl;
		CartesianPoint waypoint(x,y);
		waypoints.push_back(waypoint);    		
  	}
	planner->resetPath();
	cout << "plan generation complete" << endl;
  } 
  

 private:
  
  // Current plan generated by A*, stored as waypoints , index 0 being the beginning of the plan
  vector<CartesianPoint> waypoints;	  

};

#endif
