#include "definitions.h"
#include "CommunicationManager.h"

#include <time.h>

#include <iostream>
#include <string>
#include <sstream>
#include <cstring>
#include <vector>
#include <list>

#define COMMUNICATION_MANAGER_DEBUG true
using namespace std;

	CommunicationManager::CommunicationManager()
: mIOService(), mSocket(mIOService)
{
	//  init_provides();
	mTypeID = "coordinator";
	mNameID = "fearmanager";
	init_state();

}

CommunicationManager::~CommunicationManager()
{
	Disconnect();
}

bool CommunicationManager::Connect(const string& hostname, unsigned short port)
{
	// Prepend function signature to error messages.
	static const string signature = "CommunicationManager::Connect()";

	// Save us some typing -- I'm already feeling the effects of RSI.
	using namespace boost::system;
	using namespace boost::asio;

	// Make sure that the socket isn't already open.
	if (mSocket.is_open()) {
		Disconnect();
	}

	error_code ec; // Used to check for errors.

	// Get the IP address of the host.
	ip::address addr = ip::address::from_string(hostname, ec);
	if (ec) {
		if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - failed to retrieve host's IP address" << endl;
		return false;
	}

	// Connect to the host.
	ip::tcp::endpoint endpt(addr, port);
	mSocket.connect(endpt, ec);
	if (ec) {
		if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - failed to connect to host" << endl;
		return false;
	}

	// Go back to the initial state.
	init_state();
	return true;
}

void CommunicationManager::Disconnect()
{
	// Prepend function signature to error messages.
	static const string signature = "CommunicationManager::Disconnect()";

	// Save us some typing -- I'm already feeling the effects of RSI.
	using namespace boost::system;
	using namespace boost::asio;

	// Make sure that the socket is already open.
	if (!mSocket.is_open()) return;

	error_code ec; // Used to check for errors.

	// Shutdown the connection.
	mSocket.shutdown(ip::tcp::socket::shutdown_both, ec);
	if (ec) {
		if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - failed to disconnect" << endl;
	}

	// Close the socket.
	mSocket.close(ec);
	if (ec) {
		if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - failed to close the socket" << endl;
	}
}

bool CommunicationManager::isCommAlive() const{
	return mSocket.is_open();
}

void CommunicationManager::Update()
{
	// Prepend function signature to error messages.
	static const string signature = "CommunicationManager::Update()";

	// Save us some typing -- I'm already feeling the effects of RSI.
	using namespace boost::system;
	using namespace boost::asio;

	// Make sure that the socket is already open.
	if (!isCommAlive()) return;

	error_code ec; // Used to check for errors.

	// update the sensor readings


	// Maintain the state machine.
	switch (mCurrentState) {
		case STATE_INIT: {
					 do_state_action_init();
				 } break;
		case STATE_ACK: {
					do_state_action_ack();
				} break;
		case STATE_IDLE: {
					 do_state_action_idle();
				 } break;
		case STATE_PING_SEND: {
					      do_state_action_ping_send();
				      } break;
		case STATE_PONG_READ: {
					      do_state_action_pong_read();
				      } break;
		case STATE_PONG_SEND: {
					      do_state_action_pong_send();
				      } break;
		case STATE_CMD_PROC: {
					     do_state_action_cmd_proc();
				     } break;
		default: {
				 if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - unrecognized state" << endl;
				 do_state_change(STATE_QUIT);
			 } break;
	}

	// Update behavior.
	/*if (mBehavior && !mPossessed) {
	  mBehavior->Update();
	  }*/
}

void CommunicationManager::init_state()
{
	mCurrentState = STATE_INIT;
	mSessionID    = -1;
	mPossessed    = false;

}

bool CommunicationManager::msg_waiting() const
{
	// Prepend function signature to error messages.
	static const string signature = "CommunicationManager::msg_waiting()";

	// Save us some typing -- I'm already feeling the effects of RSI.
	using namespace boost::system;
	using namespace boost::asio;

	// Make sure that the socket is already open.
	if (!isCommAlive()) return false;

	error_code ec; // Used to check for errors.

	// Check the socket.
	size_t payload = mSocket.available(ec);
	if (ec) {
		if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - failed to peek at the socket" << endl;
		return false;
	} else if (payload >= sizeof(cmd_len_t)) {
		return true;
	} else {
		return false;
	}
}

bool CommunicationManager::read(std::stringstream& ss)
{
    // Prepend function signature to error messages.
    static const string signature = "CommunicationManager::read()";

    // Make sure that the socket is already open.
    if (!isCommAlive()) return false;

    // Read the message.
    boost::asio::streambuf inputBuffer;
    try {
        cmd_len_t len;
        boost::asio::read(mSocket, boost::asio::buffer(&len, sizeof(cmd_len_t)));
        size_t n = boost::asio::read(mSocket, inputBuffer.prepare(len));
        inputBuffer.commit(n);
    } catch (boost::system::system_error) {
        if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - failed to read message" << endl;
        return false;
    }

    // Convert the message into a workable format.
    istream is(&inputBuffer);
    // Clear the contents of the argument.
    ss.str("");
    // Fill the argument with the message that we just read.
    ss << is.rdbuf();

    // Spam standard out so that the user can feel like they're in the Matrix.
    if (COMMUNICATION_MANAGER_DEBUG)
        cout << mNameID << "::read = [" << ss.str() << "]" << endl;

    return true;
}

bool CommunicationManager::write(const stringstream& ss)
{
    // Prepend function signature to error messages.
    static const string signature = "CommunicationManager::write()";

    // Make sure that the socket is already open.
    if (!isCommAlive()) return false;

    // Compute the maximum size of a message.
    const static size_t num_bits = 8 * sizeof(cmd_len_t);
    const static string::size_type max_size = (1 << num_bits) - 1;

    // Make sure that the message doesn't exceed the maximum size.
    string msg = ss.str();
    if (msg.size() > max_size) {
        if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - message is too large" << endl;
        return false;
    }

    // Build the message.
    boost::asio::streambuf outputBuffer;
    ostream os(&outputBuffer);
    // First the preamble: size of the message.
    cmd_len_t len = static_cast<cmd_len_t>(msg.size());
    os.write(reinterpret_cast<const char *>(&len), static_cast<streamsize>(sizeof(cmd_len_t)));
    // Now the message itself.
    os << msg;

    // Send the message.
    try {
        size_t n = boost::asio::write(mSocket, outputBuffer.data());
        outputBuffer.consume(n);
    } catch (boost::system::system_error) {
        if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - failed to send message" << endl;
        return false;
    }

    // Spam standard out so that the user can feel like they're in the Matrix.
    if (COMMUNICATION_MANAGER_DEBUG)
        cout << mNameID << "::sent = [" << msg << "]" << endl;

    return true;
}

void CommunicationManager::do_state_change(int state)
{
    // Don't make false changes.
    if (mCurrentState != state) {
        if (state == STATE_INIT) {
            init_state();
        } else {
            mCurrentState = state;
        }
    }
}

void CommunicationManager::do_state_action_init()
{
    // Prepend function signature to error messages.
    static const string signature = "CommunicationManager::do_state_action_init()";

    // Send the INIT command.
    stringstream ss;
    ss << CMD_INIT << " " << mTypeID << " " << mNameID << " " << mProvidesList.size();

    for (vector<string>::const_iterator iter = mProvidesList.begin();
            iter != mProvidesList.end(); ++iter) {
        ss << " " << *iter;
    }

    if (write(ss)) {
        if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - success; next state: STATE_ACK" << endl;
        do_state_change(STATE_ACK);
    } else {
        if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - failure; next state: STATE_INIT" << endl;
        do_state_change(STATE_INIT);
    }
}

void CommunicationManager::do_state_action_ack()
{
    // Prepend function signature to error messages.
    static const string signature = "CommunicationManager::do_state_action_ack()";

    // Don't block while waiting for the command.
    if (!msg_waiting()) return;

    // Prepare to read the command.
    stringstream ss;
    string cmd;
    long session_id;
    if (read(ss) && (ss >> cmd >> session_id) && (cmd.find(CMD_ACK) != string::npos)) {
        if (session_id < 0) {
            mSessionID = -1;
            if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - rejected; next state: STATE_QUIT" << endl;
            do_state_change(STATE_QUIT);
        } else {
            mSessionID = session_id;
            if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - accepted; next state: STATE_IDLE" << endl;
            do_state_change(STATE_IDLE);
        }
    } else {
        if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - failure; next state: STATE_INIT" << endl;
        do_state_change(STATE_INIT);
    }
}

void CommunicationManager::do_state_action_idle()
{
    // Prepend function signature to error messages.
    static const string signature = "CommunicationManager::do_state_action_idle()";

    if (msg_waiting()) {
        if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - received command; next state: STATE_CMD_PROC" << endl;
        do_state_change(STATE_CMD_PROC);
    }
}

void CommunicationManager::do_state_action_ping_send()
{
    // Prepend function signature to error messages.
    static const string signature = "CommunicationManager::do_state_action_ping_send()";

    // Send the PING command.
    stringstream ss;
    ss << CMD_PING;
    if (write(ss)) {
        if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - success; next state: STATE_PONG_READ" << endl;
        do_state_change(STATE_PONG_READ);
    } else {
        if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - failure; next state: STATE_PING_SEND" << endl;
        do_state_change(STATE_PING_SEND);
    }
}

void CommunicationManager::do_state_action_pong_read()
{
    // Prepend function signature to error messages.
    static const string signature = "CommunicationManager::do_state_action_pong_read()";

    // Don't block while waiting for the command.
    if (!msg_waiting()) return;

    // Prepare to read the command.
    stringstream ss;
    string cmd;
    if (read(ss) && (ss >> cmd) && (cmd.find(CMD_PONG) != string::npos)) {
        if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - success; next state: STATE_IDLE" << endl;
        do_state_change(STATE_IDLE);
    } else {
        if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - failure; next state: STATE_PING_SEND" << endl;
        do_state_change(STATE_PING_SEND);
    }
}

void CommunicationManager::do_state_action_pong_send()
{
    // Prepend function signature to error messages.
    static const string signature = "CommunicationManager::do_state_action_pong_send()";

    // Send the PONG command.
    stringstream ss;
    ss << CMD_PONG;
    if (write(ss)) {
        if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - success; next state: STATE_IDLE" << endl;
        do_state_change(STATE_IDLE);
    } else {
        if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - failure; next state: STATE_PONG_SEND" << endl;
        do_state_change(STATE_PONG_SEND);
    }
}

void CommunicationManager::do_state_action_cmd_proc()
{
    // Prepend function signature to error messages.
    static const string signature = "CommunicationManager::do_state_action_cmd_proc()";

    // Don't block while waiting for the command.
    if (!msg_waiting()) return;

    // Prepare to read the command.
    stringstream ss;
    string cmd;
    if (read(ss) && (ss >> cmd)) {

        // Reset message source id before we (possibly) get it from the header
        sourceID = -1;

        // A source header has been set
        if ( cmd == SOURCE_SINGLE || cmd == SOURCE_MULTI )
        {
            sourceType = cmd;
            if (! (ss >> sourceID) )
            {
                if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - malformed source header; next state: STATE_IDLE" << endl;
                do_state_change(STATE_IDLE);
            }

            // The remainder of the message (after header is stripped)
            string remainder;
            getline(ss, remainder);

            ss.clear();
            ss.str(remainder);

            if (! (ss >> cmd) )
            {
                if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - no command after source header; next state: STATE_IDLE" << endl;
                do_state_change(STATE_IDLE);
            }
        }

        if (cmd.find(CMD_PING) != string::npos)
        {
            if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - PING; next state: STATE_PONG_SEND" << endl;
            do_state_change(STATE_PONG_SEND);
        }
        else if (cmd.find(CMD_QUIT) != string::npos) {
            if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - QUIT; next state: STATE_QUIT" << endl;
            do_state_change(STATE_QUIT);
        }
        else {
            if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - unrecognized command; next state: STATE_IDLE" << endl;
            do_state_change(STATE_IDLE);
        }
    }
    else {
        if (COMMUNICATION_MANAGER_DEBUG) cerr << signature << " - failure; next state: STATE_IDLE" << endl;
        do_state_change(STATE_IDLE);
    }
}

