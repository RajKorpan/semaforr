#include "CollisionManager.h"

int CollisionManager::next_collision_id_ = 0;


std::vector<long> CollisionManager::getTeammatesForAltCostMsg() {
  std::vector<long> tmates; 
    
  std::map<long, double>::iterator iter; 
  for(iter = computed_alter_costs_.begin(); iter != computed_alter_costs_.end(); iter++) {
    if(iter->second != -1) 
      tmates.push_back(iter->first); 
  }
  
  return tmates;
}


void CollisionManager::resetCollisions() {
  if(COLLISION_DEBUG)
    std::cout << "Resetting collisions" << std::endl;

  std::vector<Collision>::iterator it; 
  for(it = collisions_.begin(); it != collisions_.end(); it++) {
    it->resetCollision(); 
    computeAlterationCost(it->getTeammateID()); 
    it->print();
  }
}


bool CollisionManager::isAllResolved() { 
  std::vector<Collision>::iterator iter;
  for(iter = collisions_.begin(); iter != collisions_.end(); iter++) 
    if(!(iter->waitingForTeammate() || iter->rightOfWay() || iter->isTied()))
      return false;
  return true; 
}


bool CollisionManager::waitingForAnyTeammate() { 
  std::vector<Collision>::iterator iter;
  for(iter = collisions_.begin(); iter != collisions_.end(); iter++)
    if(iter->waitingForTeammate())
      return true;
  return false; 
}


bool CollisionManager::tiedWithAnyTeammate() {
  std::vector<Collision>::iterator iter;
  for(iter = collisions_.begin(); iter != collisions_.end(); iter++)
    if(iter->isTied())
      return true;
  return false; 
}


bool CollisionManager::isFrontClear() {
  std::vector<Collision>::iterator iter;
  for(iter = collisions_.begin(); iter != collisions_.end(); iter++)
    if(!bel_->isTeammateBehind(iter->getTeammateID()))
      return false;
  return true; 
}


vector<long> CollisionManager::getTiedTeammates() {
  std::vector<long> tied_teammates; 
  std::vector<Collision>::iterator iter;
  for(iter = collisions_.begin(); iter != collisions_.end(); iter++)
    if(iter->isTied())
      tied_teammates.push_back(iter->getTeammateID());
  return tied_teammates;
}


vector<long> CollisionManager::getTiesMaxDist() {
  std::vector<long> ties_max_dist; 
  std::vector<Collision>::iterator iter;
  for(iter = collisions_.begin(); iter != collisions_.end(); iter++)
    if(iter->isTied() && iter->getTieDecision() == NA && iter->getAlterationCostSent() == Collision::max_dist_)
      ties_max_dist.push_back(iter->getTeammateID());
  return ties_max_dist;
}


vector<long> CollisionManager::getTiesNonMaxDist() {
  std::vector<long> ties_non_max_dist; 
  std::vector<Collision>::iterator iter;
  for(iter = collisions_.begin(); iter != collisions_.end(); iter++)
    if(iter->isTied() && iter->getTieDecision() == NA && iter->getAlterationCostSent() != Collision::max_dist_)
      ties_non_max_dist.push_back(iter->getTeammateID());
  return ties_non_max_dist;
}


void CollisionManager::breakTieByID(long t_id) {
  Collision * c = getCollisionTeammate(t_id); 
  if(COLLISION_DEBUG)
    std::cout << "my_id: " << m_id_ << " \t t_id: " << t_id << std::endl;
  if(m_id_ < t_id) {
    if(COLLISION_DEBUG)
      std::cout << "Tie broken by ID: ROW" << std::endl;     
    c->setTieDecision(ROW); 
  }
  else {
    if(COLLISION_DEBUG)
      std::cout << "Tie broken by ID: YIELD" << std::endl;     
    c->setTieDecision(YIELD); 
  }
}


std::vector<Position> CollisionManager::getMoveAwayList() {
  std::vector<Position> positions; 
  std::vector<Collision>::iterator iter;
  for(iter = collisions_.begin(); iter != collisions_.end(); iter++)
    if(iter->getTieDecision() == MOVE_AWAY) 
      positions.push_back(bel_->getTeammatePosition(iter->getTeammateID()));
  return positions;
}


bool CollisionManager::isDecisionMadeInFavor() {
  std::vector<Collision>::iterator iter;
  for(iter = collisions_.begin(); iter != collisions_.end(); iter++)
    if((iter->isTied() && ( iter->getTieDecision() == NA || iter->getTieDecision() == YIELD)) || 
       iter->waitingForTeammate())
      return false;
  return true;
}


void CollisionManager::updateCollisionInfo(long t_id) {
  const string signature = "CollisionManager::updateCollisionInfo()> ";
  
  updateTeammateLookup(); 

  if(bel_->isRobotTeammate(t_id)) {
    
    updateNavgraph();

    // if the teammate is not in collision zone and has sent an alter cost earlier, remove that cost from the temp storage
    if(!bel_->isTeammateInCollisionZone(t_id) && 
       alt_cost_recvd_buffer_[t_id] != -1) {
      if(COLLISION_DEBUG)
	std::cout << signature << "Teammate " << t_id << " sent an alter cost earlier. " 
		  << "it is not in the collision zone after the information update. Discarding the cost" << std::endl;
      alt_cost_recvd_buffer_[t_id] = -1; 
    }


    if(bel_->isTeammateInCollisionZone(t_id)) {
      if(!isCollisionRecorded(t_id)) {
	if(COLLISION_DEBUG)
	  std::cout << signature << "New! I am in collision zone with " << t_id << std::endl;
	addNewCollision(t_id);
	computeAlterationCost(t_id); 
      }
    }
    else {
      if(isCollisionRecorded(t_id)) {
	if(COLLISION_DEBUG)
	  std::cout << signature << "No more danger! Finalizing collision with " << t_id << std::endl;
	finalizeCollision(t_id); 
      }
    }


    // after all the updates if we have a valid collision and if there is an alteration cost sent prior to detecting this collision, 
    // add that cost to the collision
    Collision * c = getCollisionTeammate(t_id); 
    if(c->getID() != invalid_id_ && alt_cost_recvd_buffer_[t_id] != -1) {
      if(COLLISION_DEBUG)
	std::cout << signature << "Alteration cost: " << alt_cost_recvd_buffer_[t_id] 
		  << " was sent prior to detection of this collision. " 
		  << "Setting the alteration cost of the teammate based on this value." << std::endl;
      getCollisionTeammate(t_id)->setTeammateAlterationCost(alt_cost_recvd_buffer_[t_id]);
      alt_cost_recvd_buffer_[t_id] = -1; 
    }
      
    if(COLLISION_DEBUG) {
      std::cout << signature << std::endl;
      printCollision(t_id);
    }

  }
  else {
    if(COLLISION_DEBUG)
      std::cout << signature << "Teammate with session id: " << t_id << " is not found in Beliefs!" << std::endl;
  }
}


void CollisionManager::updateAlterationCost(long t_id, double cost) {
  const string signature = "CollisionManager::updateAlterationCost()> ";
  
  updateTeammateLookup(); 

  if(!bel_->isRobotTeammate(t_id)) { 
    if(COLLISION_DEBUG)
      std::cout << signature << "Teammate with session id: " << t_id << " is not found in Beliefs!" << std::endl;
    return;
  }
    
  if(COLLISION_DEBUG)
    std::cout << signature << "Received alteration cost: " << cost << ", from teammate:" << t_id << std::endl;

  // conditions 1 & 2
  if(isCollisionRecorded(t_id)) {
    
    Collision * c = getCollisionTeammate(t_id);
    c->setTeammateAlterationCost(cost);

    if(COLLISION_DEBUG)
      std::cout << signature << "Known collision:" << c->getID() 
		<< ". Teammate's alteration cost is set to: " 
		<< c->getTeammateAlterationCost() << std::endl;
    
    // condition 2
    if(c->isAltCostResend()) { 
      computeAlterationCost(t_id); 
      if(COLLISION_DEBUG)
	std::cout << signature 
		  << "Received cost changed the resolution of the collision. Recomputed alteration cost." 
		  << std::endl;
    }

    printCollision(t_id);

    return; 
  }

  
  // condition 3: the teammate is in collision zone and the collision wasn't recorded
  if(bel_->isTeammateInCollisionZone(t_id)) {
    
    if(COLLISION_DEBUG)
      std::cout << signature << "Unknown Collision, teammate in collision zone. creating new!" << std::endl;
    
    updateCollisionInfo(t_id); 
    getCollisionTeammate(t_id)->setTeammateAlterationCost(cost); 
    
    printCollision(t_id);

    return;
  }

  // condition 5: the teammate is inside buffer zone and the collision wasn't recorded
  if(bel_->isTeammateInBufferZone(t_id)){
    if(COLLISION_DEBUG)
      std::cout << signature << "Teammate in buffer zone" << std::endl;
    alt_cost_recvd_buffer_[t_id] = cost;

    printCollision(t_id);
  }

}


void CollisionManager::setTeammateYieldReason(long t_id, std::string reason) {
  const std::string signature = "CollisionManager::setTeammateYieldReason()> "; 
  
  Collision * c = getCollisionTeammate(t_id); 
  
  if(c->getID() != -1) {
    if(reason.compare("NONE") == 0) {
      c->setTeammateYieldReason(NONE);
    }
    else if(reason.compare("NO_TARGET") == 0) {
      c->setTeammateYieldReason(NO_TARGET);
    }
    else if(reason.compare("TASK_WAIT") == 0) {
      c->setTeammateYieldReason(TASK_WAIT);
    }
    else if(reason.compare("TASK_EXECUTE") == 0) {
      c->setTeammateYieldReason(TASK_EXECUTE);
    }
    else if(reason.compare("TARGET_TOO_CLOSE") == 0) {
      c->setTeammateYieldReason(TARGET_TOO_CLOSE);
    }
    else if(reason.compare("NO_PATH") == 0) {
      c->setTeammateYieldReason(NO_PATH);
    }
    else {
      std::cerr << signature << "The reason " << reason << " for yield is not recognized" << std::endl;
      return;
    }

    makeDecision(c); 
  }
} 


void CollisionManager::addNewCollision(long t_id) {
  id_ = next_collision_id_++;
  Collision c(id_, t_id); 
  collisions_.push_back(c); 
  collision_lookup_[t_id] = id_; 
}


Collision* CollisionManager::getCollision(int id) {
  std::vector<Collision>::iterator iter; 
  for(iter = collisions_.begin(); iter != collisions_.end(); iter++)
    if(iter->getID() == id) 
      return &(*iter); 
  return invalid_collision_;
}


void CollisionManager::finalizeCollision(long t_id) {
  const string signature = "CollisionManager::finalizeCollision()> ";
  
  Collision* c = getCollisionTeammate(t_id);
  
  if(COLLISION_DEBUG)
    std::cout << signature << "Finalizing Collision[" << c->getID() << "] with " << t_id << std::endl;

  if(c->getID() != invalid_id_) {
    c->finalizeCollision();

    // get a copy of the collision object and add it to finalized_collisions_
    Collision ct = (*c);
    finalized_collisions_.push_back(ct);
    
    if(COLLISION_DEBUG)
      std::cout << signature << "Collision[" << c->getID() << "] is added to finalized collisions: " << std::endl;

    vector<Collision>::iterator itr; 
    for(itr = finalized_collisions_.begin(); itr != finalized_collisions_.end(); itr++)
      itr->print();
    
    // remove the collision from ongoing collision collection
    std::vector<Collision>::iterator it;
    for(it = collisions_.begin(); it != collisions_.end(); it++) {  
      if(it->getID() == c->getID()) {
	collisions_.erase(it);
	break;
      }
    }

    if(COLLISION_DEBUG)
      std::cout << signature << "Updating collision_lookup_ and finishing here" << std::endl;
    
    // update lookup
    collision_lookup_[t_id] = invalid_id_;
  }
  else {
    std::cerr << signature << "Collision with " << t_id << " not found in collisions collection" << std::endl;
  }
}


void CollisionManager::updateNavgraph() {
  std::vector<long> ids = bel_->getTeammateIDs();
  
  planner_->clearGraph();

  std::vector<long>::iterator it; 
  for(it = ids.begin(); it != ids.end(); it++) {
    Position robot_i_curr = bel_->getTeammatePosition(*it);
    int size = bel_->getSize(*it); 
    if(bel_->isTeammateInCollisionZone(*it))
      planner_->addObstacle(robot_i_curr.getX(), robot_i_curr.getY(), size * robot_size_buffer_); 
  }
}


void CollisionManager::computeAlterationCost(long t_id) {
  const string signature = "CollisionManager::computeAlterationCost()> ";

  if(COLLISION_DEBUG) 
    std::cout << signature << "computing cost for " << t_id << std::endl;

  // check if we have a target, if not yield
  if(planner_->getTarget().getID() == Node::invalid_node_index ) {
    if(COLLISION_DEBUG)
      std::cout << signature << "I'm not moving" << std::endl;
    Collision * coll = getCollisionTeammate(t_id); 
    if(COLLISION_DEBUG)
      std::cout << signature << "collision id " << coll->getID() << std::endl;
    setTaskYieldReason(coll);
    computed_alter_costs_[t_id] = Collision::max_dist_;
    return;
  }

  int cost = 0; 
  int curr_length = 0, new_length = 0; 
  
  // set to cost to max_dist_ (yield) if our target is in the vicinity of the teammate
  int size = bel_->getSize(t_id); 
  Position pos = bel_->getTeammatePosition(t_id);
  double dist = Utils::get_euclidian_distance(pos.getX(), 
					      pos.getY(), 
					      planner_->getTarget().getX(), 
					      planner_->getTarget().getY());
  if(dist < size) {
    if(COLLISION_DEBUG) {
      std::cout << signature << "Our target ";
      planner_->getTarget().printNode(); 
      std::cout << " is located very close to teammate " << t_id  << " with size:" << size
		<< " at (" << pos.getX() << "," << pos.getY() << ") with distance:" << dist << std::endl;
    }
    computed_alter_costs_[t_id] = Collision::max_dist_;     
    setYieldReason(getCollisionTeammate(t_id), TARGET_TOO_CLOSE);
    return; 
  }
  

  if(COLLISION_DEBUG)
    std::cout << "calculating an alterative plan" << std::endl;

  list<pair<int,int> > new_plan = planner_->getPathXYBetween(bel_->getCurrentPosition().getX(), 
							     bel_->getCurrentPosition().getY(),
							     planner_->getTarget().getX(),
							     planner_->getTarget().getY()); 
  
  if(COLLISION_DEBUG) {
    std::cout << signature << "Alternative plan from current position(" << bel_->getCurrentPosition().getX() << "," 
	      << bel_->getCurrentPosition().getY() << ") to target(" 
	      << planner_->getTarget().getX() << "," << planner_->getTarget().getY() << "):" << std::endl;
  
    planner_->printPath(new_plan); 
  }
  
  // check if we have a plan
  if(new_plan.size() == 0) {
    if(COLLISION_DEBUG)
      std::cout << signature << "We don't have a path" << std::endl; 
    setYieldReason(getCollisionTeammate(t_id), NO_PATH);
    cost = Collision::max_dist_; 
  }
  // check if source or target is invalid
  else if(new_plan.size() == 1) {
    if(new_plan.front().first == -1 || new_plan.front().second == -1) {
      if(COLLISION_DEBUG)
	std::cout << signature << "We don't have a path. Invalid(" 
		  << new_plan.front().first << "," << new_plan.front().second << ")" << std::endl; 
      setYieldReason(getCollisionTeammate(t_id), NO_PATH);
      cost = Collision::max_dist_; 
    }
  }
  // plan is good
  else {
    // if the teammate is behind us just claim the right of way    
    if(bel_->isTeammateBehind(t_id)) {
      if(COLLISION_DEBUG)
	std::cout << signature << "Teammate's behind. Claiming right of way" << std::endl;
      cost = Collision::min_dist_; 
      //getCollisionTeammate(t_id)->setTeammateAlterationCost(0);
    }
    else {
      new_length = planner_->getPathLength(new_plan); 
      curr_length = planner_->getRemainingPathLength(bel_->getCurrentPosition());
      cost = new_length - curr_length;

      if(COLLISION_DEBUG) {
	std::cout << signature; 
	std::cout << "\tnew plan length: " << new_length << std::endl;
	std::cout << "\tCurrent plan from current position(" << bel_->getCurrentPosition().getX() << "," 
		  << bel_->getCurrentPosition().getY() << ") to target(" 
		  << planner_->getTarget().getX() << "," << planner_->getTarget().getY() << "):" << std::endl;
	planner_->printPath(); 
	std::cout << "\tcurrent plan length: " << curr_length << std::endl;
      }
    }
  }
  
  // check if the calculated cost is -1, which is reserved for specifying that a cost is not received. 
  cost = (cost == -1) ? -2 : cost;
  
  if(COLLISION_DEBUG)
    std::cout << signature << "Computed cost " << cost << std::endl;

  computed_alter_costs_[t_id] = cost;
}


void CollisionManager::updateTeammateLookup() {
  std::vector<long> tmate_ids = bel_->getTeammateIDs(); 
  std::vector<long>::iterator it; 
  for(it = tmate_ids.begin(); it != tmate_ids.end(); it++) {
    if(collision_lookup_.find(*it) == collision_lookup_.end())
      collision_lookup_[*it] = invalid_id_;
    if(computed_alter_costs_.find(*it) == computed_alter_costs_.end())
      computed_alter_costs_[*it] = -1;
    if(alt_cost_recvd_buffer_.find(*it) == alt_cost_recvd_buffer_.end())
      alt_cost_recvd_buffer_[*it] = -1;
  }
}


void CollisionManager::setTaskYieldReason(Collision * new_coll) {

  const string signature = "CollisionManager::setTaskYieldReason()>";

  if(COLLISION_DEBUG)
    std::cout << signature << "setting YR for collision: " << new_coll->getID() << std::endl;
  
  // we have a current task but we are not moving
  if(bel_->getCurrentTask() != NULL && 
     planner_->getTarget().getID() == Node::invalid_node_index) {
    
    TASK_STATUS status = bel_->getCurrentTask()->getStatus();
    // if we are here it means we don't have a set target, which means we are waiting for another teammate to arrive
    if(status == ENROUTE) { 
      if(COLLISION_DEBUG)
	std::cout << signature << "Yielding reason: TASK_WAIT" << std::endl; 
      setYieldReason(new_coll, TASK_WAIT); 
      return; 
    }
    
    if (status == READY || status == IN_PROGRESS) {
      if(COLLISION_DEBUG)
	std::cout << signature << "Yielding reason: TASK_EXECUTE" << std::endl; 		
      setYieldReason(new_coll, TASK_EXECUTE); 
      return;
    }
  }
  
  // We don't have an assigned task 
  if(bel_->getAgenda().size() == 0 &&
     planner_->getTarget().getID() == Node::invalid_node_index) {
    if(COLLISION_DEBUG)
      std::cout << signature << "Yielding reason: NO_TARGET" << std::endl; 
    setYieldReason(new_coll, NO_TARGET); 
    return; 
  } 
  
  // if we haven't exit the function up to this point
  std::cerr << signature << "Undecided reason for yielding" << std::endl;
}

  
void CollisionManager::setYieldReason(Collision * coll, YieldReason reason) {
  coll->setYieldReason(reason); 
  makeDecision(coll);
}


void CollisionManager::makeDecision(Collision * coll) {
  
  const string signature = "CollisionManager::makeDecision()> "; 

  YieldReason m_res = coll->getYieldReason(); 
  YieldReason t_res = coll->getTeammateYieldReason(); 
  
  if(m_res == NONE || t_res == NONE) {
    coll->setTieDecision(NA);
    return; 
  }
  
  if(COLLISION_DEBUG)
    std::cout << signature << "Yield reason acquired from both parties. making a decision" << std::endl;

  // check for the special case we are closing in on a task where the teammate might be waiting for us
  if(m_res == TARGET_TOO_CLOSE && t_res == TASK_WAIT) {
    // set the decision to ROW, approach to target
    coll->setTieDecision(ROW);

    if(COLLISION_DEBUG)
      std::cout << signature << "ROW: Approaching to our target for task execution" << std::endl;
  }
  
  // cases where we should get the right of way
  else if((m_res == TASK_WAIT && t_res == NO_TARGET) || 
	  (m_res == TASK_EXECUTE) ||
	  (m_res == NO_PATH && t_res == NO_TARGET) ||
	  (m_res == TASK_WAIT && t_res == NO_PATH) ||
	  (m_res == TASK_WAIT && t_res == TARGET_TOO_CLOSE)) {
    coll->setTieDecision(ROW); 
    if(COLLISION_DEBUG)
      std::cout << signature << "ROW" << std::endl;
  }    
  
  // cases where we should yield (again) and wait for the other robot to move
  else if((m_res == NO_TARGET && t_res == TASK_WAIT) ||
	  (t_res == TASK_EXECUTE) ||
	  (m_res == TARGET_TOO_CLOSE && t_res == NO_TARGET) ||
	  (m_res == TARGET_TOO_CLOSE && t_res == NO_PATH) ||
	  (m_res == NO_PATH && t_res == TASK_WAIT)) {
    coll->setTieDecision(YIELD);
    if(COLLISION_DEBUG)
      std::cout << signature << "YIELD" << std::endl;
  }
  
  // cases where we should move out of the way
  else if((m_res == NO_TARGET && t_res == TARGET_TOO_CLOSE) || 
	  (m_res == NO_PATH && t_res == TARGET_TOO_CLOSE) ||
	  (m_res == NO_TARGET && t_res == NO_PATH)) {
    coll->setTieDecision(MOVE_AWAY);
    if(COLLISION_DEBUG)
      std::cout << signature << "MOVE_AWAY" << std::endl;
  }
  
  else if ((m_res == TARGET_TOO_CLOSE && t_res == TARGET_TOO_CLOSE) || 
	   (m_res == NO_PATH && t_res == NO_PATH)) { 
    if(COLLISION_DEBUG)
      std::cout << signature << " Both reasons are the same: " << Collision::getYRString(m_res) 
		<< " breaking ties by ID" << std::endl;
    // if the tie should be broken by ID but the decision is MOVE_AWAY
    if(m_id_ < coll->getTeammateID()) {
      coll->setTieDecision(MOVE_AWAY);
      if(COLLISION_DEBUG)
	std::cout << signature << "MOVE_AWAY" << std::endl;
    }
    else {
      coll->setTieDecision(YIELD);
      if(COLLISION_DEBUG)
	std::cout << signature << "YIELD" << std::endl;
    }
  }

  else if (m_res == t_res) {
    if(COLLISION_DEBUG)
      std::cout << signature << " Both reasons are the same: " << Collision::getYRString(m_res) 
		<< " ROW will be granted to both parties in case they have to move due to other collision ties" << std::endl;

      coll->setTieDecision(ROW);
      if(COLLISION_DEBUG)
	std::cout << signature << "ROW" << std::endl;
  }

}
