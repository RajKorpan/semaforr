/*! 
 * Collision.cpp
 *
 * \brief Keeps track of collision resolution instance with a single teammate robot
 *
 * This class manages low level information regarding a single collision (with a single robot)
 *
 * \author A. Tuna Ozgelen
 * \date 1/16/2014 Created
 */

#include <Collision.h>


void Collision::setTeammateAlterationCost(double c) {
  if(alteration_cost_ != -1) 
    alt_cost_resend_ = isResolutionChanges(c);

  if(c != max_dist_)
    tmate_yield_reason_ = NONE; 
  
  alteration_cost_ = c; 
  resolveCollision();
}


void Collision::resetCollision() { 
  row_ = false; 
  wait_ = false; 
  tied_ = false; 
  decision_ = NA; 
  yield_reason_ = NONE;
}


void Collision::finalizeCollision() {
  if(tied_) {
    state_ = UNRESOLVED; 
    return;
  }
  
  if(alteration_cost_ == -1) {
    state_ = NO_RESPONSE;
    return;
  }
  
  if(alteration_cost_sent_ == min_dist_) {
    state_ = CLAIMED; 
    return;
  }
  
  if(wait_)
    state_ = YIELDED;
  else if(row_)
    state_ = RIGHT_OF_WAY;
}


//! \brief prints the status of collision for debugging purposes
void Collision::print() const {
  std::cout << "Collision[" << id_ << "]:\n"
	    << "\tWith teammate ID: " << t_id_ << "\n"
	    << "\tCost Recv'd:\t" << alteration_cost_ << "\n"
	    << "\tCost Sent:\t" << alteration_cost_sent_ << "\n"
	    << "\tYield Reason:\t" << getYRString(yield_reason_) << "\n"
	    << "\tTMate Yield R:\t" << getYRString(tmate_yield_reason_) << std::endl;
  switch(state_) {
  case ONGOING: 
    std::cout << "\tWaiting?:\t" << wait_ << "\n"
	      << "\tRightOfWay?:\t" << row_ << "\n"
	      << "\tTied?:\t" << tied_ << "\tdecision: " << decision_<< std::endl;
    break;
  case NO_RESPONSE:
    std::cout << "\tCollision finalized : Teammate did not respond. " << std::endl;
    break;
  case CLAIMED:
    std::cout << "\tCollision finalized : Teammate was behind therefore claimed the right of way. " << std::endl;
    break;
  case YIELDED:
    std::cout << "\tCollision finalized : Yielded to the teammate. " << std::endl;
    break;
  case RIGHT_OF_WAY:
    std::cout << "\tCollision finalized : Got the right of way and moved first. " << std::endl;
    break;
  case UNRESOLVED:
    std::cout << "\tCollision finalized : The collision was unresolved and handled at a higher level:" << std::endl;
    std::cout << "\tMy Yield Reason:" << Collision::getYRString(yield_reason_) 
	      << "\tTeammate's Yield Reason:" << Collision::getYRString(tmate_yield_reason_) << std::endl;
    switch(decision_) {
    case NA:
      std::cout << "\t\tCollision was finalized before a decision was made." << std::endl;
      break;      
    case ROW:
      std::cout << "\t\tRight of way acquired." << std::endl;
      break;      
    case YIELD:
      std::cout << "\t\tYielded." << std::endl;
      break;
    case MOVE_AWAY:
      std::cout << "\t\tMoved out of the way." << std::endl;
      break;
    }
  }
}


void Collision::resolveCollision() {
  if(alteration_cost_ != -1 && alteration_cost_sent_ != -1) {
    wait_ = false; 
    row_ = false;
    tied_ = false;

    if(alteration_cost_sent_ > alteration_cost_)
      wait_ = true;
    else if (alteration_cost_sent_ < alteration_cost_)
      row_ = true;
    else 
      tied_ = true; 
  }
}


bool Collision::isResolutionChanges(double c) {
  // if not resolved return false
  if(wait_ || row_ || tied_) {
    if(wait_ && c >= alteration_cost_sent_)
      return true; 
    if(row_ && c <= alteration_cost_sent_)
      return true; 
    if(tied_ && c != alteration_cost_sent_)
      return true; 
  }
  return false; 
}
